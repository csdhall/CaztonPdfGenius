hi everyone this is gkcs in this video we'll be talking about 20 white papers that you must know as a back-end engineer especially if you are in a senior engineering position or staff level position the benefit of reading a white paper is that you get to know the implementation details and the Practical aspects of Building Systems so most of the trade-offs that are chosen when building a system come from the product requirements of the system in the case of these white papers the product requirements are being decided by other Engineers who will be using that system for example you have the system at meta which is called memcached like it's an open source software which Facebook has modified for their own use one of the problems they're facing was scaling so they need to deploy many nodes of map cache challenges of routing routing one thing which came up was should you choose sharding over redundancy sharding basically means you have a key space and that key space is divided into sets each set is given to a set of servers and redundancy means that you have the same key space being handled by multiple servers simultaneously the problem here with multiple servers is that they may be eventually consistent and also the cost of managing multiple servers for a small key space as you see this problem is not as big as the other problem of starting for Facebook because they had a concept of aggregate queries so when a client request would come for let's say the profile the profile also had friend connections it also had likes on a post a news feed so it was a complex query hitting multiple shards and so splitting the key space would have only made things worse for them so this is an example of one trade-off each of the papers that I'm really talking about are really interesting and you should have a look so let's start number 20 monolith this is a real-time recommendation system white paper this is from Tick Tock their Engineers have found a way to give recommendations to millions of users in real time so one of the problems with any recommendation algorithm is you have a set of users you have a real-time component to it and a batch component to it but the recommendations in the real-time section are not very good model that found a way to embed features of users right the basic idea here would be that gaurav likes to watch let's say chess videos and a person who likes to watch chess videos may also like to program so an embedding can be thought of as a point in a n-dimensional space gaurav has a particular age so that is the x-axis gaurav is a male that's a y-axis gaurav is from India that's on the z-axis like I said he likes watching chess videos so probably you're watching chess video maybe a alpha axis and so on you have n dimensions in this gaurav is a point and people who are close to him usually tend to watch the same things how do you efficiently embed gaurav in a space and also give him recommendations is a serious problem in many of these useless news feed applications so as an engineer it makes sense to look at the kind of scale that you're dealing with 19 flexi raft this is a paper by meta it's a very interesting paper because when you look at the raft algorithm you have this concept of Quorum where a majority of the nodes agree on a particular value the problem with this is scalability if you you add more and more nodes a majority of those nodes have to agree on a value it's not easy to do and also it doesn't make sense when you have a globally distributed system the Indian servers have to agree to the U.S server's value maybe the Europe servers also have to come in so a global system of Quorum is not what you're looking for you're looking for a tree like structure where the Indian surgery on a particular value and they have a leader who talks to the leader of the US who talks to the leader of Europe this tree hierarchy also needs to be roughly consistent so Facebook has come up with this algorithm called flexi raft it's really interesting to look at I think it will also give you an idea of how raft Works internally or if you are really into it paxos we have discussed that in interview ready also pretty useful to know how this good consensus Works number 18 is spanner spanner is also around dispute consensus but it's around how a database can work how it can give you strong consistency guarantees how it can offer transactions and spanner is a very popular example for a Geo distributed database which is strongly consistent and also highly available Google has spent millions of dollars making sure that their clocks are all in sync and it's a feat of engineering which is worth looking at spanner is expected to survive the worst of faults even if things are on fire there's an expectation that spanner is going to be up so it's good to look at what kind of fault all mechanisms Google has employed number 17 Minesweeper Minesweeper is again meta it's a root cause analysis system you can imagine this to be something which identifies what caused a problem so you have anomaly detection if you have any kind of a smooth graph if it's a straight line one differentiation will make it flat if it's a parabola two differentiations will make it flat but if it's not if it's a very complex graph with anomalies three differentiations will show you all the problem points okay and you can catch them and say that these are economies once you have detected these anomalies how do you identify what caused the anomaly you are probably going to look at factors which are highly correlated to the graph that you're looking at a change in the contributing factor is probably what has caused the final change that you're seeing in your business Matrix if you see sales are low but actually what has really happened is Landings on the website alone then you should probably focus on The Landings instead of trying to fix Minesweeper is an automated system it's really interesting to think about how much automation can help you for a startup of course it doesn't really make sense because you can do this manually but in medium to large organizations it makes a lot of sense number 16 Cassandra Cassandra is an extremely popular database it talks about how the database uses the cluster architecture the gossip protocol how it chooses certain trade-offs like consistency or availability however Frankly Speaking did give me Vibes that you know it's an open source clone of Amazon dynamodb it's totally fine I mean I totally understand open source Technologies are very important it's important to have these possible solutions for us small companies to leverage but as a white paper yes it probably is not the world's best white paper having said that as an engineer it's worth reading number 15 Foundation DP Foundation DB is really interesting because the kind of testing techniques that they have employed to make sure that their transactions work in this nosql database are novel right the stocks also on Foundation DB other thing is that it's a key value data store so that's the most popular kind of data store when it comes to you know SQL databases and it's worth the read when it comes to highly consistent systems which are also scalable and it's a paper by Apple so there's some diversity in these white papers number 14 Amazon Aruba Aurora is more like an architecture pattern that Amazon uses when it comes to managing databases so the key factors here are scale Amazon wants to scale enormously and they also want to give you very high availability so how do they ensure that how do they add and remove nodes seamlessly how do they also hide the complexity of Aurora from their clients you want to give some sort of customizability but you also don't want startups to break their heads while using your system so it's an interesting set of trade-offs that they have picked up in this paper and it's definitely worth reading number 13 tackle brackle is a system by Google this is a graph processing system it's not necessarily maintaining graphs but finding patch atoms in graphs so page ranking algorithms finding out interesting websites ranking those websites all of this is usually done in batch it's a very old system by Google which gives a good idea of how it probably works behind the scenes once you know this you might have a decent idea of how SEO works for Google in fact some of the aspects for the pregnant people are very practical so it makes sense as an engineer to read this quite well number 12 Apple Dapper is another system by Google it's a tracing system if you have a request which is going through possibly hundreds of services then it's very difficult to trace that request to find out what happened at what point in time Dapper is probably the first step when it comes to root cause analysis for example you probably can't take all requests you want to do some sort of sampling of requests you don't want to log every line of the request you want some points which when reached trigger an event and say that okay this thing happened to this request okay especially at scale it doesn't make sense to log everything one interesting thing about Dapper is that whenever a system tries to integrate this service engineers at Depot check whether you are hitting it the right way because you shouldn't be impacting the rest of the services at Google so it's not just code reviews now it's actually inter-system code reviews number 11 chubby chubby is a system very similar to Apache zookeeper Google came up with this system for disputed locks and that's a fundamental component of any kind of transaction or any kind of leader election that you have internally it employs paxos paper doesn't talk about paxos anymore instead it focuses on the Practical as of implementing such a large scale distributed Locking System for example what do you do you probably use a file system to manage the logs you need some sort of notifications to be sent whenever a lock is held or released if you want a high level understanding of paxos interview ready has a lesson on that 10. mega store mega store is a data store at Google which provides relational database semantics so Google usually goes for nosql but Megastore is a highly scalable highly reliable system which gives you asset transactions and also an rdbms like feel it's interesting to look at what kind of trade-offs they have made here again and also how they've tested the system how they make sure that what they have built actually works in such a large environment what I found interesting was that internally Megastore uses big table which is a nosql data store how do you map rdbms to a nosql data store makes you feel like how databases actually work you have a very simple let's say Hardware system or a file system which is back all of your data even in the database so how do you build relational data on top of something which doesn't provide you that right how do you build indexes so Megastore is definitely worth it number nine big table big table is a fundamental database solution for Google it's a nosql data store it's actually something which Powers many of the systems in Google including I think the search engine you have multiple versions of the data that can be stored so if you have an older version of a page and then you have a newer version of the page you can have all of that in one data store called bigtable many of the principles of bigtable like hot shots and keeping multiple shards consistent is now considered common practice but when it was made it was a really big deal and of course the ideas are very intelligent it's a very practical database solution that Google came up with at a time when nosql was not a very common solution number eight map reduce the map reduce architecture is one of the most important core architecture pieces that any data engineer or software engineer can look at as the system scale you have very Services storing data and this data needs to be processed for analytics reasons recommendations sometimes just for storage archival how do you do this efficiently with commodity Hardware more than a decade ago when Google came up with a solution of mapreduce it was extremely normal and very intelligent in fact immediately open source Solutions started coming out using this kind of an architecture which is absolutely amazing if you have seen Apache spark or Apache Hadoop they end up using mapreduce or some variation of it internally it's a must tweet for engineers who should know about this architecture because some of the concepts are in fact now used also in programming languages Java has this concept of mapping filtering reducing and at interview ready we have explained this architecture in detail number eight Google file system this is probably the world's most popular technical white paper when it comes to software Engineers Google file system is a way in which Google stores data it doesn't necessarily need to be file data bigtable for example uses Google file system so it forms a basic layer on top of other high level system and for Google I'm sure it makes a lot of sense to build their own file system how do file system is something you might have heard of there are tremendous similarities when it comes to Hadoop and Google Google came out first and I think Hadoop has taken inspiration again which is totally again like I said fine you you need open source Alternatives and solutions for your own systems but the original paper is very well written uh it's very easily understandable and the trade-offs which are made to ensure that this file system is consistent and performant makes a lot of sense it's a must read for engineers number six Tau t-a-l or Tau from meta is a very interesting system which is basically an in-memory graph database for meta it makes a lot of sense to have an in-memory graph database because they have the social network that they want to pass to map this information you could use relational databases you could use nosql databases you can try to hack your way through through adjacency lists but none of them really work at scale so instead they have a dedicated in-memory graph database called Tau and some of the Practical considerations when it comes to keeping this data consistent and highly available are absolutely amazing tau is I think an engineering Marvel like you should as an engineer definitely read up on it number five memcached memcached is an amazing Solution by Facebook the best part about this is the practicality of their decisions I think we touched on this earlier but there's a ton of of trade-offs and a ton of optimizations that Facebook has made on memcache should you use TCP or UDP well it depends on the situation should you go for sharding or application like we said it depends on the situation here they chose the application so there's a ton of trade-offs a ton of practical applications that memcache at Facebook has and the white paper is definitely worth the review it's probably the top five papers that you can look at number four Monarch Google Monarch is a Time series database the reason why I'm mentioning this so high up is because Monarch is again a very practical database something that Google uses at scale with very high reliability to monitor their systems Monarch is expected to run even if all the other systems have gone down including their database if the database is down Monarch is supposed to say hey the database has gone down now how do you do that right because to some extent you are going to be tracking your patterns and anomalies through database graphs so you have to keep everything in memory and as a Time series database at Google scale that's a ton of memory that's in petabytes the byte paper is absolutely amazing it's definitely worth the read number three gorilla DB gorilla DB is not a database it's an in-memory database you can call it a cache and it's a Time series database Facebook again does something similar to in fact you'll see them come up with the same logical conclusions both companies Google and Facebook created their own time series database Monarch and gorilla and then eventually they say that we are going to be doing something different so Facebook says the recently timed events are the most important ones and Google says I'm not going to make that assumption and because of that they have trade-offs they make architectural decisions which are different right but Facebook for me I I find them really interesting in the sense that they they choose performance very often they choose practicality very often for a startup it makes more sense or they resonate more with me so their white paper was a personal preference I think Monarch is of course engineering by is more of a marble I would say but yeah gorilla is definitely both leading behind the scenes it uses open tsdp so it kind of cheats on the persistence side and it's in the top three papers that I would go for number two Amazon dynamodb this is a very popular database Solution by Amazon in fact I think it propelled their engineering Fields complex algorithms like resource level algorithms so when it comes to Mercury to make sure that data is moved from one place to another consistent hashing and all of this actually implemented dynamodb has extremely high levels of availability it's very performant its consistency is also pretty amazing and it's a solution that is offered by AWS to everybody in the world it's one of the most impactful papers in the world so it's worth looking into number one what Zanzibar this is a system by Google it's been open source now the reason I'm mentioning Zanzibar on top as the best paper probably that you can read there are so many practical optimizations made by Google to make sure that their authentication system runs efficiently the algorithm for authentication you know the the data schema or the apis is just hardly one page that's the idea that this concept then comes optimization or optimization or optimization and I'm like really impressed by Google that they made this open source that you can actually use this 90 you probably either won't need it or you can just go to gcp which probably uses it internally you don't really need to build it but the aspects around rate limiting the aspects around fault tolerance when it comes to Zanzibar are absolutely mind-blowing some of these Concepts I had explained at interview ready in the rate limiting chapter the first one and then I got to see that Zanzibar is implementing them in reality and at scale right so it's interesting to see how Theory meets practicality but but when you are at let's say a billion users making billions of requests per day it's definitely worth the read for every engineer do check it out so that's all I have for the white papers that you should read as a software engineer the papers are neatly organized and put in one blog post the link is in the description do check it out let me know what white papers you like with a short description of why you like it maybe you know it talks about trade-offs practicality the scale the ease of understanding the paper and if you found something particularly interesting we can actually have a discussion on them in the comments below until next time I'll see you bye 